# yaml-language-server: $schema=values.schema.json
---
schema: "1.0"

# nameOverride: ''
# fullnameOverride: ''

# ## Global values are used for subcharts
# global:
#   gateway: istio-system/private
#   # -- Required
#   applicationName: testapp
#   # -- Required
#   customerName: testapp
#   # -- Required - Used for resource tracking with labels and used for ArgoCD naming
#   impactLevel: il2
#   # -- Required
#   environment: dev
#   # -- Required for using ArgocdWrapper method with subCharts key
#   destinationCluster: multi-tenant-development-cluster
#   image:
#     # -- Use this with <microservice-name>.image.name instead of using <microservice-name>.image.repository to reduce duplicate yaml code in values.yaml
#     defaultImageRegistry: registry.gamewarden.io
#     defaultImageRepository: testapp
#   # -- Istio settings
#   istio:
#     # -- enforce mtls PeerAuthentication
#     mtls:
#       enabled: true

# ciliumNetworkPolicies:
#   enabled: false
#   appPolicy:
#     enabled: true
#   # -- To add additional policies to the app namespace
#   customPolicies: []
#   #  - name: custom-policy-1
#   #    spec:
#   #      endpointSelector:
#   #       matchLabels: {}
#   #      egress:
#   #       - toCIDR:
#   #         - 192.168.1.0/24
#   #      ingress:
#   #       - fromCIDR:
#   #         - 10.0.0.0/16
# networkPolicies:
#   enabled: false
#   appPolicy:
#     enabled: true
#   # -- To add additional netpols to the app namespace
#   customPolicies: []
#   #  - name: custom-policy-1
#   #    spec:
#   #      podSelector:
#   #       matchLabels: {}
#   #      egress:
#   #       - toCIDR:
#   #         - 192.168.1.0/24
#   #      ingress:
#   #       - fromCIDR:
#   #         - 10.0.0.0/16

# imageCredentials: []

# rbac:
#   create: false
#   rules: []
#   # RBAC rules for KUBE_PING
#   #  - apiGroups:
#   #      - ""
#   #    resources:
#   #      - pods
#   #    verbs:
#   #      - get
#   #      - list

# # -- Global application configmap - used for all microservices deployed to one namespace
# config:
#   enabled: false
#   data: {}
#   annotations: {}

# # -- Global application secret - used for all microservices deployed to one namespace
# secrets:
#   enabled: false
#   # data:
#   #   test0: test0
#   #   test1: test1
#   # stringData:
#   #   test2: test2
#   #   test3: test3
#   # generateKeys:
#   #   - DB_PASSWORD
#   #   - JOB_SECRET

# # ref: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
# # Support secret types: "Opaque", "kubernetes.io/tls", "kubernetes.io/basic-auth", Opaque-nuget
# generateSecretsJob:
#   enabled: false
#   # image: ''  # image used for the job
#   secrets: {}
# # [example usage](docs/test-values/secrets-generation.yaml) 

# defaults:
#   # -- domain for istio virtual services
#   domain: gamewarden.io
#   # -- istio virtual service from chart enabled
#   virtualService:
#     enabled: false
#   # -- Number of replicas for the microservice
#   replicaCount: 1
#   #  statefulsets: min # of secs for which a newly created Pod should be ready without any of its containers crashing

#   # https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
#   strategy: {}
#     # type: RollingUpdate
#     # rollingUpdate:
#     #   maxSurge: 25%
#     #   maxUnavailable: 25%

#   minReadySeconds: 0

#   image:
#     pullPolicy: IfNotPresent
#     # -- Required - repository tag along with either repository or name (one is required)
#     tag: ''
#   # -- Pull secrets for the image/s
#   imagePullSecrets:
#     - name: private-registry
#   serviceAccount:
#     # -- Specifies whether a service account should be created
#     create: false
#     # -- Annotations to add to the service account
#     annotations: {}
#     labels: {}
#     # -- The name of the service account to use.
#     # -- If not set and create is true, a name is generated using the fullname template
#     name: 'default'

#   podAnnotations: {}

#   podSecurityContext: {}
#     # fsGroup: 2000

#   securityContext:
#     allowPrivilegeEscalation: false
#     capabilities:
#       drop:
#       - ALL
#     readOnlyRootFilesystem: true
#     runAsNonRoot: true
#     # runAsUser: 1000

#   # -- Extra environment variables
#   extraEnvs: {}
#     # - name: EXAMPLE
#     #   value: example
#     # - name: EXAMPLE_FROM
#     #   valueFrom:
#     #     secretKeyRef:
#     #       name: mysecret
#     #       key: password
#     #       optional: false

#   # -- Extra environment variables from secrets or configMaps
#   envFrom: []
#     # - secretRef:
#     #     name: mysecret
#     # - configMapRef:
#     #     name: myconfig

#   # -- Example Pod Disruption Budget values
#   podDisruptionBudget: {}
#     # minAvailable: 5
#     # maxUnavailable: 1

#   service:
#     # -- Use a service with Microservice
#     enabled: true
#     # -- Set the service to headless
#     headless: false
#     # -- Set the service type (ClusterIP, NodePort, LoadBalancer, ExternalName )
#     type: ClusterIP
#     # -- Set the port you want to expose the service on.
#     port: 80
#     # -- Set a name for the port
#     name: http
#     # -- Set to true to remove the port name
#     disablePortName: false
#     # disableIstioInjection: true # used in rare circumstances where you do not want the service to be injected with the Istio sidecar
#     # -- Set the default targetPort of service to 8080 ( Port the application is listening on within the container )
#     targetPort: 8080
#     # -- Set the app procotol to allow explicit selection. (http, http2, https, tcp, tls, grpc, mongo, mysql, redis)
#     appProtocol: TCP
#     # -- Add additional ports to expose
#     additionalPorts: {}
#     #   - port: 69
#     #     targetPort: 6969
#     #     protocol: TCP
#     #     name: http

#   resources:
#     # by default run without limits, and no limitRanges are set
#     # limits:
#     #   cpu: "2"
#     #   memory: 2Gi
#     requests:
#       cpu: 100m
#       memory: 128Mi
#   autoscaling:
#     #  -- Horizontal Autoscaling of pods - see [configuration example for usage](docs/Example-Microservices.md) for more information.
#     enabled: false
#     minReplicas: 1
#     maxReplicas: 10

#   # -- Restrict a Pod to only be able to run on a particular Node.
#   nodeSelector: {}
#   # -- Applied to pods, and allow (but do not require) the pods to schedule onto nodes with matching taints.
#   tolerations: []
#   # -- Ensure that pods are hosted on specific nodes
#   affinity: {}


# # -- Extra kubernetes objects to deploy inline - Takes in MAP or LIST
# # @schema
# # type: [array, object]
# # @schema
# extraManifests: []
#   #   yourNameOfFirstResource:
#   #     apiVersion: kafka.strimzi.io/v1beta2
#   #     kind: Kafka
#   #     metadata:
#   #       name: kafka-cluster
#   #       namespace: test
#   #     spec:...
#   # - apiVersion: kafka.strimzi.io/v1beta2
#   #   kind: Kafka
#   #   metadata:
#   #       name: kafka-cluster
#   #       namespace: example
#   #   spec: ...

# # -- Extra kubernetes objects to deploy inline
# manifests: {}
#   #   yourNameOfFirstResource:
#   #     apiVersion: kafka.strimzi.io/v1beta2
#   #     kind: Kafka
#   #     metadata:
#   #       name: kafka-cluster
#   #       namespace: test
#   #     spec:...

# # Microservices: example of two services, the first being deployment and second a statefulset
# microservices: {}
# # Please refer to the [configuration example for usage](docs/Example-Microservices.md) for more information.

# # -- Used to get around ArgoCD generating new secrets with argocd ignore annotations
# generatedSecrets:
#   enabled: false

# # -- ArgoCD Wrapper for deploying extra ArgoCD Applictions, one argocd application for each subchart added below
# subCharts: {}
#   # clamav:                                       # Example subChart that is disabled
#   #   enabled: false                              # default is true
#   #   chartUrl: 'registry.gamewarden.io/charts'   # default is 'registry.gamewarden.io/charts'
#   #   chart: "clamav"                             # default is 'uchart'
#   #   name: clamav                                # renames the argocd Application to be something different, default is the subChart key
#   #   revision: 0.0.2                             # required - version of included chart
#   #   # namespace: otherNamespace                   # only desired if you want to deploy to a different namespace than your applicationName
#   #   # values: {}                                  # optional - helm values in-line
#   #   # valueFiles: []                              # optional - if used with valuesRepo, it will turn the subChart application into a multi-sourced application
#   #   # valuesRepo: ""                              # optional - git repo location of where the values files are retrieved from
#   #   # wave: ""                                    # optional - used to create the annotations for argocd sync waves
#   #   # sync: true                                  # default true - used to turn off automated sync and pruning for the subChart
#   #   # project: ""                                 # optional - default is inherited from created project - this is an override
#   #   # serverSideApply: true                       # default true

# argocd:
# # -- Disable option for creation of project for applications created from subCharts if nesting
#   disableProjectCreation: true
# # -- Add additional allowed namespaces to deploy to beyond the default single namespace from applicationName
#   sourceNamespaces: []
#   # - customerNamespaceTwo
# # -- Create all namespaces beforehand in sourceNamespaces (the main namespace auto-creates from argocd)
#   createNamespace: false
# # -- Namespace override for all argocd applications deployment
#   namespace: ""
# # -- Turn off the argocdWrapper Application.yaml template and instead deploy microservices without being under an argocd application
#   wrapperAppOff: false
#   ## Default within subCharts sets wrapperAppOff to true
# # -- Set argocd sync wave number on just the argocdWrapper Application if used
#   wrapperAppWave: ''
# # -- Sync options - Turn on or off automated syncing with pruning for the argocdWrapper Application from microservice
#   wrapperSync: true
# # -- Project override for the argocdWrapper microservice Application
#   projectOverride: ""
# # -- Server Side Apply on Application wrapper (not subCharts)
#   serverSideApply: true
# # -- wrapper all-in-one where the microservices and subCharts all are placed into a single wrapped application with multiple sources
#   wrapAll: false
# # -- wrapper all-in-one argocd application name override
#   wrapAllNameOverride: ""

##############
# New Values #
##############
global:
  # -- Set an override for the prefix of the fullname
  nameOverride:
  # -- Set the entire name definition
  fullnameOverride:
  # -- Set additional global labels. Helm templates can be used.
  labels: {}
  # -- Set additional global annotations. Helm templates can be used.
  annotations: {}
  # -- Set a global image registry
  imageRegistry: registry.gamewarden.io

# -- Set default options for all workloads / pods here
# Each of these options can be overridden on a workload level
defaultPodOptions:
  # -- Defines affinity constraint rules. Helm templates can be used.
  # [[ref]](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity)
  affinity: {}

  # -- Set annotations on the Pod. Pod-specific values will be merged with this.
  annotations: {}

  # -- Specifies whether a service account token should be automatically mounted.
  automountServiceAccountToken: true

  # -- Set image pull secrets
  imagePullSecrets: []

  # -- Set labels on the Pod. Pod-specific values will be merged with this.
  labels: {}

  # -- Node selection constraint
  # [[ref]](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector)
  nodeSelector: {}

  # -- Custom priority class for different treatment by the scheduler
  priorityClassName: ""

  # -- Set Container restart policy.
  # @default -- `Always`. When `workload.type` is `cronJob` it defaults to `Never`.
  restartPolicy: ""

  # -- Allow specifying a runtimeClassName other than the default one (ie: nvidia)
  runtimeClassName: ""

  # -- Configure the Security Context for the Pod
  securityContext: {}

  # -- Specify taint tolerations
  # [[ref]](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/)
  tolerations: []

  # -- Defines topologySpreadConstraint rules.
  # [[ref]](https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/)
  topologySpreadConstraints: []

workloads: {}
#   main:
#     # -- enable the workload.
#     enabled: true

#     # -- Set the workload type.
#     # Valid options are deployment, daemonSet, statefulSet, cronJob or job
#     type: deployment
#
#     # -- Set annotations on the deployment/statefulSet/daemonSet/cronJob/job
#     annotations: {}
#
#     # -- Set labels on the deployment/statefulSet/daemonSet/cronJob/job
#     labels: {}
#
#     autoScaling:
#       # enable autoScaling
#       enabled: false
#       # minimum amount of replicas
#       minReplicas: 1
#       # maximum amount of replicas
#       maxReplicas: 3
#       # set target memory utilization threshold
#       targetMemoryUtilizationPercentage:
#       # set target cpu utilization threshold
#       targetCpuUtilizationPercentage:
#       # set custom metrics
#       metrics 
#
#     # -- Number of desired pods. Unused when autoscaling is enabled.
#     replicas: 1
#
#     # -- Set the workload upgrade strategy
#     # For Deployments, valid values are Recreate (default) and RollingUpdate.
#     # For StatefulSets, valid values are OnDelete and RollingUpdate (default).
#     # DaemonSets/CronJobs/Jobs ignore this.
#     strategy:

#     rollingUpdate:
#       # -- Set deployment RollingUpdate max unavailable
#       unavailable:
#       # -- Set deployment RollingUpdate max surge
#       surge:
#       # -- Set statefulSet RollingUpdate partition
#       partition:
#
#     # -- ReplicaSet revision history limit
#     revisionHistoryLimit: 3

#     # -- Set the workload service account name
#     # This is entirely optional, if empty or `null` the workload will use the default service account
#     serviceAccount:
#       # -- Only use one of `name` or `id`. In case both are specified it will prioritize `id`.
#       # -- Reference a service account id from this values.yaml
#       id:
#       # -- Explicitly set the service account name
#       name:
#
#     # -- CronJob configuration. Required only when using `workload.type: cronJob`.
#     # @default -- See below
#     cronJob:
#       # -- Suspends the CronJob
#       # [[ref]](https://kubernetes.io/docs/concepts/workloads/workloads/cron-jobs/#schedule-suspension)
#       # @default -- false
#       suspend:
#       # -- Specifies how to treat concurrent executions of a job that is created by this cron job
#       # valid values are Allow, Forbid or Replace
#       concurrencyPolicy: Forbid
#       # -- Sets the CronJob timezone (only works in Kubernetes >= 1.27)
#       timeZone:
#       # -- Sets the CronJob time when to execute your jobs
#       schedule: "*/20 * * * *"
#       # -- The deadline in seconds for starting the job if it misses its scheduled time for any reason
#       startingDeadlineSeconds: 30
#       # -- The number of succesful Jobs to keep
#       successfulJobsHistory: 1
#       # -- The number of failed Jobs to keep
#       failedJobsHistory: 1
#       # -- If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to
#       # be automatically deleted.
#       ttlSecondsAfterFinished:
#       # -- Limits the number of times a failed job will be retried
#       backoffLimit: 6
#       # -- Specify the number of parallel jobs
#       parallelism:

#     # -- Job configuration. Required only when using `workload.type: job`.
#     # @default -- See below
#     job:
#       # -- Suspends the Job
#       # [[ref]](https://kubernetes.io/docs/concepts/workloads/workloads/job/#suspending-a-job)
#       # @default -- false
#       suspend:
#       # -- If this field is set, ttlSecondsAfterFinished after the Job finishes, it is eligible to
#       # be automatically deleted.
#       ttlSecondsAfterFinished:
#       # -- Limits the number of times a failed job will be retried
#       backoffLimit: 6
#       # -- Specify the number of parallel jobs
#       parallelism:
#       # -- Specify the number of completions for the job
#       completions:
#       # -- Specify the completionMode for the job
#       completionMode:

#     # -- StatefulSet configuration. Required only when using `workload.type: statefulSet`.
#     statefulSet:
#       # -- Set podManagementPolicy, valid values are Parallel and OrderedReady (default).
#       podManagementPolicy: OrderedReady

#       # -- Used to create individual disks for each instance.
#       volumeClaimTemplates: []
#       # - name: data
#       #   labels: {}
#       #   annotations: {}
#       #   globalMounts:
#       #     - path: /data
#       #   accessMode: "ReadWriteOnce"
#       #   dataSourceRef:
#       #     apiGroup: snapshot.storage.k8s.io
#       #     kind: VolumeSnapshot
#       #     name: MySnapshot
#       #   size: 1Gi
#       # - name: backup
#       #   labels: {}
#       #   annotations: {}
#       #   globalMounts:
#       #     - path: /backup
#       #       subPath: theSubPath
#       #   accessMode: "ReadWriteOnce"
#       #   size: 2Gi
#       #   storageClass: cheap-storage-class

#     # workload-specific overrides for `defaultPodOptions` keys
#     pod: {}

#     # -- Whether to apply defaultContainerOptions to initContainers
#     applyDefaultContainerOptionsToInitContainers: true
#
#     # -- Set the strategy for the default container options. Defaults to
#     #    overwrite: If container-level options are set, use those instead of the defaults.
#     #    merge: If container-level options are set, merge them with the defaults
#     # @default -- overwrite
#     defaultContainerOptionsStrategy: overwrite
#
#     # -- Set default options for all (init)Containers here
#     # Each of these options can be overridden on a container level
#     defaultContainerOptions:
#       image:
#         # -- Override the image repository for the containers
#         repository:
#         # -- Override the image tag for the containers
#         tag:
#         # -- Override the image pull policy for the containers
#         pullPolicy:
#       # -- Override the command(s) for the containers
#       command:
#       # -- Override the args for the containers
#       args:
#       # -- Environment variables.
#       env:
#       # -- Secrets and/or ConfigMaps that will be loaded as environment variables.
#       envFrom: {}
#       # -- Set the resource requests / limits for the container.
#       resources:
#       # -- Configure the Security Context for the container
#       securityContext: {}

#     containers:
#       main:
#         # -- Override the container name
#         nameOverride:

#         # -- Specify if this container depends on any other containers
#         # This is used to determine the order in which the containers are rendered.
#         dependsOn: []

#         image:
#           # -- image repository
#           repository:
#           # -- image tag
#           tag:
#           # -- image pull policy
#           pullPolicy:

#         # -- Override the command(s) for the container
#         command: []
#         # -- Override the args for the container
#         args: []
#         # -- Override the working directory for the container
#         workingDir:

#         # -- Environment variables. Template enabled.
#         # Syntax options:
#         # A) TZ: UTC
#         # B) PASSWD: '{{ .Release.Name }}'
#         # B) TZ:
#         #      value: UTC
#         #      dependsOn: otherVar
#         # D) PASSWD:
#         #      configMapKeyRef:
#         #        name: config-map-name
#         #        key: key-name
#         # E) PASSWD:
#         #      dependsOn:
#         #        - otherVar1
#         #        - otherVar2
#         #      valueFrom:
#         #        secretKeyRef:
#         #          name: secret-name
#         #          key: key-name
#         #      ...
#         # F) - name: TZ
#         #      value: UTC
#         # G) - name: TZ
#         #      value: '{{ .Release.Name }}'
#         env:

#         # -- Secrets and/or ConfigMaps that will be loaded as environment variables.
#         # Syntax options:
#         # A) Pass an app-template configMap id:
#         #    - config: config
#         # B) Pass any configMap name that is not also an id (Template enabled):
#         #    - config: random-configMap-name
#         # C) Pass an app-template configMap id, explicit syntax:
#         #    - configMapRef:
#         #        id: config
#         # D) Pass any configMap name, explicit syntax (Template enabled):
#         #    - configMapRef:
#         #        name: "{{ .Release.Name }}-config"
#         # E) Pass an app-template secret id:
#         #    - secret: secret
#         # F) Pass any secret name that is not also an id (Template enabled):
#         #    - secret: random-secret-name
#         # G) Pass an app-template secret id, explicit syntax:
#         #    - secretRef:
#         #        id: secret
#         # H) Pass any secret name, explicit syntax (Template enabled):
#         #    - secretRef:
#         #        name: "{{ .Release.Name }}-secret"
#         envFrom: []

#         # -- Probe configuration
#         # -- [[ref]](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)
#         probes:
#           # -- Liveness probe configuration
#           # @default -- See below
#           liveness:
#             # -- Enable the liveness probe
#             enabled: true
#             # -- Set this to `true` if you wish to specify your own livenessProbe
#             custom: false
#             # -- sets the probe type when not using a custom probe
#             # @default -- "TCP"
#             type: TCP
#             # -- The spec field contains the values for the default livenessProbe.
#             # If you selected `custom: true`, this field holds the definition of the livenessProbe.
#             # @default -- See below
#             spec:
#               initialDelaySeconds: 0
#               periodSeconds: 10
#               timeoutSeconds: 1
#               failureThreshold: 3

#           # -- Readiness probe configuration
#           readiness:
#             # -- Enable the readiness probe
#             enabled: true
#             # -- Set this to `true` if you wish to specify your own readinessProbe
#             custom: false
#             # -- sets the probe type when not using a custom probe
#             # @default -- "TCP"
#             type: TCP
#             # -- The spec field contains the values for the default readinessProbe.
#             # If you selected `custom: true`, this field holds the definition of the readinessProbe.
#             # @default -- See below
#             spec:
#               initialDelaySeconds: 0
#               periodSeconds: 10
#               timeoutSeconds: 1
#               failureThreshold: 3

#           # -- Startup probe configuration
#           startup:
#             # -- Enable the startup probe
#             enabled: true
#             # -- Set this to `true` if you wish to specify your own startupProbe
#             custom: false
#             # -- sets the probe type when not using a custom probe
#             # @default -- "TCP"
#             type: TCP
#             # -- The spec field contains the values for the default startupProbe.
#             # If you selected `custom: true`, this field holds the definition of the startupProbe.
#             # @default -- See below
#             spec:
#               initialDelaySeconds: 0
#               timeoutSeconds: 1
#               ## This means it has a maximum of 5*30=150 seconds to start up before it fails
#               periodSeconds: 5
#               failureThreshold: 30

#         # -- Set the resource requests / limits for the container.
#         resources:
#           {}
#           ## We usually recommend not to specify default resources and to leave this as a conscious
#           ## choice for the user. This also increases chances charts run on environments with little
#           ## resources, such as Minikube. If you do want to specify resources, uncomment the following
#           ## lines, adjust them as necessary, and remove the curly braces after 'resources:'.
#           # limits:
#           #   cpu: 100m
#           #   memory: 128Mi
#           # requests:
#           #   cpu: 100m
#           #   memory: 128Mi

#         # -- Configure the Security Context for the container
#         securityContext: {}

#         # -- Configure the lifecycle event hooks for the container
#         # -- [[ref](https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/)]
#         lifecycle: {}

#         # -- Configure the path at which the file to which the containers termination message will be written.
#         # -- [[ref](https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#lifecycle-1)]
#         terminationMessagePath:

#         # -- Indicate how the containers termination message should be populated.
#         # Valid options are `File` and `FallbackToLogsOnError`.
#         # -- [[ref](https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#lifecycle-1)]
#         terminationMessagePolicy:

#     # -- Specify any initContainers here as dictionary items.
#     # Each initContainer should have its own key
#     initContainers: {}

serviceAccount:
  # -- Specifies whether a service account should be created
  # The id for this ServiceAccount will be `default`
  create: false

  # -- Annotations to add to the service account
  annotations: {}

  # -- Labels to add to the service account
  labels: {}

  # -- The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

  # -- Additional Service Accounts to create
  # Each extra service account admit the same keys as the main service account
  extraServiceAccounts: {}
  #   serviceAccount2:
  #     create: true
  #     annotations:
  #       test: test
  #   serviceAccount3:
  #     create: true
  #     name: custom-service-account
  #     labels:
  #       test: test

# -- Use this to populate secrets with the values you specify.
# Be aware that these values are not encrypted by default, and could therefore visible
# to anybody with access to the values.yaml file.
# Additional Secrets can be added by adding a dictionary key similar to the 'secret' object.
# @default -- See below
secrets:
  {}
  # secret:
  #   # -- Enables or disables the Secret
  #   enabled: false
  #   # -- Labels to add to the Secret
  #   labels: {}
  #   # -- Annotations to add to the Secret
  #   annotations: {}
  #   # -- Secret stringData content. Helm template enabled.
  #   stringData:
  #     {}
  #     # foo: bar

# -- Configure configMaps for the chart here.
# Additional configMaps can be added by adding a dictionary key similar to the 'config' object.
# @default -- See below
configMaps:
  {}
  # config:
  #   # -- Enables or disables the configMap
  #   enabled: true
  #   # -- Labels to add to the configMap
  #   labels: {}
  #   # -- Annotations to add to the configMap
  #   annotations: {}
  #   # -- configMap data content. Helm template enabled.
  #   data:
  #     foo: bar
